\chapter{Activity Based Computing}

In this chapter we will further explain the activity-based paradigm. We will explain why adaptation and awareness is important, and introduce the activity based computing framework that will help us create an activity based client.

\section{Background}
Activity based computing is a computer paradigm that moves focus from application based computer interaction into a higher level computational support for human activities. The paradigm has its outset in clinical work on hospitals, and seeks to aggregate resources to activities, instead of specific applications. An example of such an activity could be the development of our proof of concept. Opening an activity will cause the relevant services and resources to become available to the user, and allow to user to more easily switch between activities and all their associated services and resources. Figure \ref{fig:activitychart} shows an example of the activity "Proof-of-concept development", its associated services and their resources.

\begin{figure}[h!]
  \centering
    \includegraphics[scale=1.0]{ActivityChart}
  \caption{\emph{The "Proof of Concept" activity. Illustrates how an activity encapsulates its services and resources}}
  \label{fig:activitychart}
\end{figure}

\citet{bardram2011} identifies six principles that forms the basis of the activity based computing paradigm, being; \emph{Activity Centered}, \emph{Activity Suspend and Resume}, \emph{Activity Roaming}, \emph{Acitivty Adaptation}, \emph{Activity Sharing} and \emph{Activity Awareness}. Each of these will be further described in the following.

\begin{description}

	\item[1. Activity Centered] \hfill \\
	An Activity is a computational unit that encapsulates a set of services and their relevant resources. An activity therefore encapsulate digital software and data necessary for a user to carry out their work (activity).
	
	\item[2. Activity Suspend and Resume] \hfill \\
	This allows a user to alternate between several activities and support interruptions that requires the user to perform another task. This is done by suspending the current activity and resuming another.
	
	\item[3. Activity Roaming] \hfill \\
	This principle enables activities to be stored on an infrastructure, like a server, and allows for activities to be suspended on one device, and then resumed on another, to better support user mobility.
	
	\item[4. Activity Adaptation] \hfill \\
	An activity can be displayed and handled on very different devices, and should adapt to the resources available at the resumed devices. In this case resources could be CPU power, screen size and network bandwidth.
	
	\item[5. Activity Sharing] \hfill \\
	Focuses and deals with the collaborative aspect of activities. This principle states that activities are shared among collaborators that appear on a list of participants for any particular activity. If two or more participants engage resumes the same activity they will both be notified and engage in video and audio chat if possible.
		
	\item[6. Activity Awareness] \hfill \\
	Allows for an activity to be context aware, such that it adapts itself to its current environment and work context. This could be to i.e. adapting the user interface or changing activities and services based on where the device is located.

\end{description}

Implementing all of these features enables computational devices to better support human activities, and allow users to move away from the traditional document -and application centered model on a desktop computer. In this thesis we will focus on how to display activities on the iPad and how to adapt the interface to the orientation of the iPad, how to store activities in an infrastructure and how the iPad can be aware of its surroundings. In this chapter we will further explain the principle of adaptation and awareness.

\section{Activity Adaptation and Awareness}
\label{sec:adaptaware}
In many work places it is normal for users to carry out their work in several different locations. As an example it would be natural to consider a plausible scenario for a professor during his day at a university:

\begin{quotation}
\emph{
A professor got a day full of meetings at the University. In the beginning of the day he will have a meeting with the head of a study programme at which he teaches a course. They will discuss several course related material, and course goals, and will require the use of the course website, a document with the goals of the study programme, the exercises used in the course. Later he will have a lunch meeting with a fellow colleague in the cantina, to discuss an idea for a project. During preparation he have found several online resources on the matter, and have made a few designs and diagrams he wants to share. After lunch he got a meeting in his office with a couple of students regarding a bachelor thesis, and needs to review some code written, which includes looking over several source code files, as well as a generated documentation file. Afterwards he got a meeting with a PhD student in his office, regarding his thesis that needs review, and also to discuss a certain article found online. During the meeting the search through an article database located online, and find a couple of interesting articles that they save for later use.
}
\end{quotation}

This is a thought scenario but it clearly illustrates two things: first of all there is a need to aggregate resources to certain activities during the day for easy access, and second he only need certain activities at certain locations.

The first issue can be handled by using the activity based paradigm as explained earlier, in order to encapsulate resources with different activities. Now the second issue can be handled by filtering the available activities based on where the user is as illustrated in figure \ref{fig:locationmovement}. Now in this case, only four activities have been mentioned but there might be many more than those. There might be activities planned for the rest of the week, and there might even be activities that are not work related. This could potentially sum up to quite a lot of activities and most of them are only relevant when you are in a specific location.

This is where the principle of activity awareness becomes important. Many wireless technologies exists today as explained by \citet{wirelessWiki}, which enables devices to communicate with nodes placed in a building. Using these technologies a device can communicate with these wireless nodes, and get information on its current whereabouts.

\begin{figure}[h!]
  \centering
    \includegraphics[scale=0.6]{Moving}
  \caption{\emph{Illustration on how the professor moves between locations in order to carry out his activities}}
  \label{fig:locationmovement}
\end{figure}

By using this information it is possible to keep an activity relation with specific locations in a building, and only show the activities that takes place in a given location. We can specify this kind of filtering as \emph{location filtering}. Location filtering is thus a concrete way of handling activity awareness.

With regards to activity adaptation it is interesting to consider the result of the evaluation from \citet{bardram2009}:
\begin{quotation}
	\emph{
		This means that if an activity is roamed from a display with a large resolution (e.g., 1900×1600) to one with a low resolution (e.g., 800×600), a significant portion of the activity’s application windows will potentially be left outside the visible area of the display. A related issue arose when clinicians asked for activity roaming between very large devices (e.g., the wall display in the team room) to very small devices (e.g., a PDA or a SmartPhone). In principle, the ABC framework can run on a PDA or a Java-enabled SmartPhone using the J2ME edition. The real challenge, however, is to investigate further what it actually means to roam an activity between two such very different types of devices—especially if we take into consideration that the clinicians saw the small devices as tools for more specific actions within the overall activity. One possible approach may be to support roaming a subpart of an activity to a small device, instead of roaming the whole activity.
	}
\end{quotation}

What is really interesting here is that it appears that the same kind of UI is implemented on very different devices, and that a possible solution could be to only handle a subpart of an activity. It should always be discouraged to handle very different devices similarly. It makes sense in standard desktop environments where most computers offer the same screen size and resolution, but when one moves from this environment, as is the case of activity based computing, one should also treat each family of devices differently. This means that PDA's and smartphones should have a distinct UI, tablets should have a distinct UI and so on. One could argue that this would mean a lot of overhead implement different UI's for different devices, but there exist design paradigms that takes this into account, and only require the UI part to changed, and not the rest of the implementation. It is also only natural that the UI is different as these devices would be used very differently as observed in \citet{bardram2009}:

\begin{quotation}
	\emph{
		[\ldots] especially if we take into consideration that the clinicians saw the small devices as tools for more specific actions within the overall activity
	} 
\end{quotation}

So in order to fully make use of activity adaptation, it is important to recognize that each family of devices is different, and should be treated as such, and that their usage is also different. One would probably not replace a wall display with an iPad and hope to achieve the same thing. This is important to keep in mind when designing the UI of the client on the iPad, in order to support activity adaptation properly.

\section{ABC Framework}
In the following, a short historic overview of the ABC infrastructure will be provided, up to the current version, that is used in this project. The Activity Based Computing infrastructure is managemed by the Activity Research Team. Each subsection will give a brief overview, as well as the goal for each of the mentioned infrastructures.

\subsection{ABC infrastructure version 4 - Windows XP}
In 2006, \citet{bardram2006}, implemented an extension to Windows XP that would enable it to better support the ABC paradigm. The main focus of the paper released, remained on how to provide native Windows XP OS support, for an ABC infrastructure. The infrastructure was written in Java, and worked as a client-server solution to accomodate the Windows XP integration. The infrastructure was based upon easrlier infrastructures that supported activity discovery, activity roaming and activity sharing. The main difference from this solution and earlier versions was that the client did not have to be online at all times. All changes at the client side would be stored in a cache that would be sync'ed with the infrastructure when an online connection were available. The communication between the client and the infrastructure relied on the The Activity-Based Computing Protocol, that were modeled like the HTTP protocol by using stateless, string-based, unicast socket protocol with URI and URL string syntax.

\subsection{ABC infrastructure version 5 - AEXO}
In 2011, \citet{bardram2012} implemented a new solution both on the client side and the server side. The first major change between this version and version 4, was the change from a client-server infrastructure, to a P2P infrastructure. The main focus of this infrastructure was to enable cross-device support. In version 4 the main focus was to support stationary desktop computers, using Windows XP, but now the version 5 supported several different devices and this was combined with using Adobe Flex that offered a framework for developing applications for multiple devices and operating systems. The infrastructure itself was also changed to support the AEXO infrastructure which is a minimal, flexible, extensible datastructure that can be easily distributed across several devices. The AEXO framework were used to implement a distributed model-view-controller, and furthermore the AEXO infrastructure enabled an event-based mechanism for devices, such that it was possible to keep an synchronized copy of the distributed activity model across every device.

\subsection{ABC infrastructure version 6 - RESTful}
Both version 4 and 5 of the ABC infrastructure, were targeted a specific client solution that were to be used in correlation with the infrastructure in question. In version 6 this is changed. Using a RESTful interface, the infrastructure has been moved to the cloud to make the infrastructure completely device independant. The RESTful infrastructure still enables devices to store activities by creating, updating or deleting them. This version is currently work in progress by the Activity Research Team, and have not been completed yet, but for this project it was chosen due to the fact that communication is handled by wrapping JSON into HTTP GET, POST, PUT and DELTE requests, and this makes it completely device and OS independent. This were an important feature, since we were to develop a client for a completely new OS. Since version 6 the infrastructure that we will be using we will eloborate further on how the internal components works.

Figure \ref{fig:infrastructure} shows the structure of the infrastructure. At the bottom, three example clients is mentioned, in order to show the benefits of having a cloud infrastructure. Windows XP, ReticularSpaces as well as the client we are going to develop are be based on three completely different platforms, and with three completely different implementations, but by keeping the infrastructure in the cloud all three implementations would be able to easily communicate with it. The cloud infrastructure consist of three main components; Activity Access, Activity Manager and the File Manager.

\begin{description}
	\item[Activity Access] \hfill \\
	The Activity Access handles the direct communication between the Activity Manager and the client the sends the requests. When a client makes e.g. a HTTP POST request, the Activity Access gets this request, and maps the request to a equivalent function on the Activity Manager component. Furthermore when the Activity Manager have completed the request, the Activity Access maps this result into a HTTP Response, that is sent back to the requesting client.
	\item[Activity Manager] \hfill \\
	When the Activity Manager gets a request and an input from the Activity Access, it executes the requested function on the input. The input itself is mapped to an Activity object defined in the Core library. The request is then send further to the File Manager. If the Activity Manager retrieved a GET request, meaning that the client wants to get a specific activity stored in the infrastructre, the Activity Manager asks the File Manager for the requested actvity, which is retrieved from the BLOB and handed over to the Activity Manager. If a POST or PUT is retrieved the Activity Manager asks the File Manager to update or create the Activity instead, and on DELETE requests, the File Manager is asked to remove the Activity from the infrastructure.
	\item[File Manager] \hfill \\
	The File Manager keeps track of all stored activities. It does so by using both the Data Table and Binary Large Object. The Data table is used for \emph{Activity Wrappers}. An Activity Wrapper is essentially location information about a specific activity. It consist of the ID of an activity, as well as the specific PATH location of an activity within the service. Each time a new Activity is created the Activity Wrapper is created as well and stored in the DT. The activity itself is serialized and stored in a generated PATH. When a request for that activity is received, it File Manager looks up the ID of the activity, and deserialize the activity from the PATH stored together with the ID, and hands the activity back.
\end{description}

\par\vspace{\baselineskip}

\begin{figure}[!htbp]
  \centering
    \includegraphics[scale=0.8]{architectureCloud}
  \caption{\emph{Illustration of the ABC cloud infrastructure. At the buttom three examples on ABC clients connects to the cloud. Each client sends requests to the cloud service, which is then handled by the Activity Access and mapped to functions on the Activity Manager. Each request is then mapped to an activity object and an Activity Wrapper. The Activity Wrapper is stored on the Data Table, with info on where the serialized activity object is placed, such that it can be retrieved later.}}
  \label{fig:infrastructure}
\end{figure}

\par\vspace{\baselineskip}
%Figure \ref{fig:infrastructure} shows a graphical representation of the RESTful service.
%The way the service works is by receiving request from a client through the RESTful service. These requests is then received by \emph{Activity Access} which maps the request to an internal function. That function is called on the \emph{Activity Manager}, which looks at the HTTP header of the initial response, to determine what to do with the JSON data. The JSON data is then mapped to an \emph{Activity} object. Based on this Activity object, an \emph{Activity Wrapper} is produced which is placed in the \emph{Data Table(DT)}, and the activity object itself is serialized and placed as a \emph{Binary Large Object (Blop)}, on the service.

%So for example when a GET request is issued by a client, the Activity Manger will lookup the Activity Wrapper in the Data Table, to find out where the Activity object is placed and then deserialize it and map it to JSON data and finally send it back as a response.